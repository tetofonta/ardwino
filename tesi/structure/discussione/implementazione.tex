\chapter{Implementazione}

In questo capitolo verranno discussi gli sviluppi relativi al firmware sostitutivo programmato sull'ATMega16U2 della scheda \textit{Arduino UNO R3} illustrando livello per livello le soluzioni adottate e le relative motivazioni.

\section{Modifiche hardware alla scheda}\label{s:dw-board-mod}

Come discusso nell'introduzione la scheda \textit{Arduino UNO R3} non presenta alcun supporto al debugging o a estensioni per tale funzione.

Questo comporta la necessità di sviluppare una nuova scheda derivata dall'architettura di \textit{Arduino UNO} --- il cui sviluppo comporterebbe un dispendio di energie e tempo non indifferenti e alte possibilità di errore --- oppure la modifica hardware e firmware di un esemplare della stessa al fine di introdurre tale funzionalità.

Affinché sia possibile utilizzare l'interfaccia di debugging DebugWire è necessaria una connessione con pull-up diretta con il pin i reset dell'integrato.

Come è possibile osservare dall'allegato~\ref{app:r3-schematic}, L'integrato \texttt{U3} è connesso al pin di reset del target (\texttt{U4}) tramite il condensatore \texttt{C5} (si veda la \cref{fig:r3-schematic-rst-detail}). Sarà dunque necessario rimuovere tale condensatore e ripristinare una connessione diretta tra i micro-controllori come evidenziato dalla \cref{fig:remove-c5}.

\begin{figure}[t]
    \hfill
    \begin{minipage}{.45\textwidth}
        \subfloat[][]{\includegraphics[width=.9\textwidth]{cap_begin.png}}
    \end{minipage}
    \begin{minipage}{.45\textwidth}
        \subfloat[][]{\includegraphics[width=.5\textwidth]{cap_removed.png}} \\
        \subfloat[][]{\includegraphics[width=.5\textwidth]{cap_shorted.png}}
    \end{minipage}
    \hfill
    \caption[]{Procedimento di rimozione del condensatore \texttt{C5}. Il condensatore viene rimosso (b) e successivamente la connessione viene ripristinata (c)}\label{fig:remove-c5}
\end{figure}

Tale modifica rende inoperabile il firmware presente sul controllore ATMega16U2 in quanto così facendo la linea di reset rimarrebbe asserita al livello logico 0 durante la durata della connessione con l'\texttt{host} impedendone il funzionamento sia da un punto di vista logico che fisico, essendo che il cambiamento comporterebbe il collegamento dei componenti \texttt{RN2D} e \texttt{RN1D}. Questi costituiscono così un partitore di tensione che imporrebbe la linea di reset ad un livello logico insufficiente ad una tensione di \SI{450}{\milli\volt}. 
Per questa motivazione si rende necessaria una seconda modifica isolando la resistenza \texttt{RN2D} tagliando la traccia che la collega alla linea di reset come mostrato in \cref{fig:cut-rnd2}

\begin{figure}[b]
    \centering
    \includegraphics[width=.25\textwidth]{cut_rnd2.png}
    \caption[]{Isolamento del componente \texttt{RN2D} tagliando la traccia evidenziata.}\label{fig:cut-rnd2}
\end{figure}

Questa modifica si ripercuote negativamente sulla possibilità di eseguire il bootloader sull'ATMega16U2, in quanto è necessario che il pin 13 sia posto a \SI{0}{\volt} perché esso possa essere caricato\cite[sec 23.6.3]{avr:m16u2}. Vi sono quindi tre possibilità:
\begin{enumerate}
    \item Caricare il firmware personalizzato antecedentemente alle modifiche hardware.
    \item Utilizzare un programmatore esterno tramite l'header di programmazione \texttt{ICSP1}
    \item Collegare temporaneamente durante il reset dell'ATMega16U2 la traccia tagliata con l'ausilio di uno strumento conduttivo.
\end{enumerate} 

\subsection{Riutilizzo del pulsante di reset}

La connessione per il debugging, trattasi di una linea seriale open drain, comporta che il pulsante di reset presente sulla scheda non sia più funzionante, in quanto le funzionalità originali del pin di reset vengono disattivate con l'attivazione della periferica DebugWire.

La soluzione adottata consiste nell'implementazione di un soft-reset gestito dal microcontrollore ATMega16U2: La connessione del pulsante viene modificata in modo che esso sia un input letto dal firmware modificato del micro-controllore adattatore, il quale si occuperà di resettare il \textit{target} mediante l'invio di una sequenza di comandi descritta dall'algoritmo seguente:
\begin{enumerate}
    \item Halt del target (BREAK)
    \item Reset del controllore (0x07)
    \item Ripresa dell'esecuzione (0x30)
\end{enumerate}

A tal fine è necessario installare una connessione ausiliaria tramite un filo e tagliare la traccia di connessione del pulsante come mostrato dalla \cref{fig:rst-rewire}. Il valore del pulsante sarà letto dal pin \texttt{PINB6} il quale viene configurato come input con pull-up abilitato, filtrando in seguito il segnale tramite una procedura di \textit{debouncing} illustrata dal~\cref{lst:debounce}.

\noindent\begin{minipage}{\textwidth}
    \begin{lstlisting}[style=C, caption={Routine di interrupt di TIMER0 per la gestione del debounce}, label=lst:debounce]
    ISR(TIMER0_OVF_vect){
[...]
        if(usr_pshbtn_debounce_counter++ == 16) 
            //Incrementa il contatode per il debuounce.
            //Se 16 allora termina il periodo di insensibilità
            global_debounce = 0;
    }

    void usr_btn_task(user_button_state_t * btn){
        if((*btn->pin_register) & (1 << btn->pin)){
            //Se il segnale è 1 allora salva lo stato
            btn->last_state = 1; 
        } else {
            if(btn->last_state && !global_debounce){
                //Se il segnale era uno durante la precedente 
                // iterazione ed ora è 0 dopo aver trascorso 
                // il periodo di insensibilità emetti l'evento.
                usr_btn_event(btn);

                //reset e ripristino
                global_debounce = 1;
                usr_pshbtn_debounce_counter = 0;
                TCNT0 = 0;
            }
            btn->last_state = 0;
        }
    }
    \end{lstlisting}
\end{minipage}

Il frammento di codice presentato è stato pensato per l'esecuzione secondo il concetto di attività periodica. La variabilità del segnale derivato dalla pressione di un pulsante da parte dell'utente ha tempi notevolmente lunghi rispetto alla frequenza di esecuzione, risultando quindi un'operazione senza alcun tipo di priorità e necessità di esecuzione in tempo reale.

È quindi possibile eseguire periodicamente l'operazione inserendola nel ciclo infinito presente in ogni programma nella funzione main.

Viene quindi deciso un periodo di insensibilità ai cambiamenti del segnale il quale viene gestito dal TIMER0. Questo timer, inizialmente configurato dal firmware per avere un incremento ogni 1024 cicli di clock, genererà un interrupt di \textit{overflow} ogni \SI{16}{\milli\second}, periodo ancora troppo breve in confronto alle durate degli eventi causati dall'utente. Per ovviare a tale problematica un ulteriore contatore è implementato in software al fine di terminare tale periodo di insensibilità dopo circa \SI{250}{\milli\second} come è possibile osservare dalle righe 3-6.\@

\begin{figure}[h]
    \centering
    \subfloat[][]{\includegraphics[width=.2\textwidth]{rst-solder-front.png}}
    \hspace{8mm}
    \subfloat[][]{\includegraphics[width=.2\textwidth]{rst-solder-rear.png}}

    \caption[]{Procedimento di isolamento e riutilizzo del pulsante di reset mostrato dal lato superiore (a) e inferiore (b). Si noti la traccia tagliata nell'immagine (b)}\label{fig:rst-rewire}
\end{figure}

\section{Livello Fisico}

Come riportato nella \cref{ss:dw-phy}, l'interfaccia tra debug server, l'ATMega16U2, e il controllore target è costituita da una linea seriale open drain.

Si rende necessario quindi implementare tale interfaccia in modo efficiente al fine di permettere al server GDB di interfacciarsi con il \textit{target} tramite DebugWire.

L'implementazione inizialmente progettata in fase di ideazione, ancora prima che fosse stabilita la piattaforma hardware, sfruttava una periferica UART.\@ Al fine di implementare l'accesso della periferica --- la quale fa affidamento a due line \textit{point-to-point} tra i due attori della comunicazione --- alla linea open drain si rende necessario l'utilizzo di un componente aggiuntivo come mostrato nella \cref{fig:od-impl}, la quale mostra due alternative di implementazione utilizzando un diodo o un transistor. 

\begin{figure}[t]
    \centering

    \subfloat[][]{
        \begin{circuitikz}
            \draw (0, 0) node[label={[font=\footnotesize]above:rxd}] {} to[short, *-] (2, 0) to[short, -] (2, 1) to[R={\(R_{pullup}\)}] (2, 2) to [short, -] (2, 2.5) to [short, -] (2.5, 2.5) to [short, -] (2.5, 3);
            \draw (2.5, 2.5) to[short, -] (3, 2.5) to[short, -] (3, 2) to[R={\(R1\)}] (3, 1);
            \draw (3,-1) node [npn,xscale=-1,anchor=B] (npn) {\reflectbox{Q1}} (npn.collector);
            \draw (3, 1) to[short, -] (3, -1);
            \draw (2, 0) to[short, *-*] (4, 0) node[label={[font=\footnotesize]above:tgt}] {};
            \draw (0, -2) node[label={[font=\footnotesize]above:txd}] {} to[short, *-]  (2.16, -2) to[short, -] (2.16, -1.75);
            \draw (2.16, 0) to[short, *-] (2.16, -0.5);
            \draw (2, 3) -- node[anchor=south,align=center] {VCC} (3, 3);
        \end{circuitikz}
    }
    \subfloat[][]{
        \begin{circuitikz}
            \draw (0, 0) node[label={[font=\footnotesize]above:rxd}] {} to[short, *-] (2, 0) to[short, -] (2, 1) to[R={\(R_{pullup}\)}] (2, 2) to [short, -] (2, 3);
            \draw (1.5, 3) -- node[anchor=south,align=center] {VCC} (2.5, 3);
            \draw (2, 0) to[short, *-*] (4, 0) node[label={[font=\footnotesize]above:tgt}] {};
            \draw (2, 0) to[short, -] (2, -0.5) to[D={D1}] (2, -1.5) to[short, -] (2, -2)  to [short, -*] (0, -2) node[label={[font=\footnotesize]above:txd}] {};
        \end{circuitikz}
    }
    \caption[]{L'immagine mostra due possibili circuiti per l'adattamento della periferica UART dell'ATMega16U2 alla linea seriale open drain.}\label{fig:od-impl}
\end{figure}

Il principio di funzionamento dei circuiti in \cref{fig:od-impl} è pressoché identico: Il valore del pin \textit{txd} viene replicato sulla linea di connessione al nodo \textit{tgt} con un livello logico 0 ``forte'' e un livello logico 1 ``debole'' dato dalla resistenza \(R_{pullup}\) e in entrambi i casi il pin \textit{txd} viene utilizzato come collettore di corrente.
La differenza consiste nella quantità di componenti aggiuntivi e nelle prestazioni.

Il circuito (a) permette, tramite il pin \textit{txd}, di porre la differenza di potenziale \(V_{be}\) tra base ed emettitore del transistor a circa \SI{5}{\volt}\footnote{ignorando la caduta di tensione irrilevante sulla resistenza \texttt{R1}}, permettendo una corrente di base sufficiente a mandare il transistor in saturazione imponendo così la tensione sulla connessione verso il target a livello logico 0.

Contrariamente il circuito (b) sfrutta il diodo \texttt{D1} per ottenere lo stesso risultato. La differenza consta nel fatto che nel circuito (a) il transistor permette di avere una caduta di tensione minore essendo in saturazione, cosa che avviene quando il segnale \textit{txd} è zero, mentre il diodo \texttt{D1} causa una caduta di tensione dell'ordine di \SI{700}{\milli\volt}.

I circuiti sopra introdotti sono verificati dalle simulazioni, allegate al documento~\ref{app:ngspice-bjt}, eseguite con il software \textit{ngspice}\cite{site:ngspice} i cui risultati sono riportati in \cref{graph:sim}. In aggiunta a quanto esibito, il circuito (b) è stato simulato con un diodo schottky 1N5817 con capacitanza di giunzione pari a \SI{125}{\pico\farad} per valutarne il comportamento.

\begin{figure}[hp]
    \centering
        \begin{tikzpicture}
            \begin{axis}[
                width=0.8\textwidth,
                xlabel={Tempo (S)},
                ylabel={Tensione (V)}
                ]
                \addplot table [x=t, y=v(tgt), col sep=comma, mark=none] {sims/phy-sim-bjt.csv};
                \addplot table [x=t, y=v(txd), col sep=comma, mark=none] {sims/phy-sim-bjt.csv};
                \legend{$tgt$,$txd$}
            \end{axis}
        \end{tikzpicture}\\
        \vfill
        \begin{tikzpicture}
            \begin{axis}[
                width=0.8\textwidth,
                xlabel={Tempo (S)},
                ylabel={Tensione (V)}
                ]
                \addplot table [x=t, y=v(tgt), col sep=comma, mark=none] {sims/phy-sim-diode.csv};
                \addplot table [x=Time, y=V(NODE1), col sep=comma, mark=none] {sims/phy-sim-schottky.csv};
                \addplot table [x=t, y=v(txd), col sep=comma, mark=none] {sims/phy-sim-diode.csv};
                \legend{$tgt (pn)$,$tgt (schottky)$,$txd$}
            \end{axis}
        \end{tikzpicture}
    \caption[]{Risultati della simulazione dei circuiti in \cref{fig:od-impl} con tempo di bit pari a \SI{8}{\text{\mu}\second} (\SI{125}{\kilo\hertz}). Parametri della simulazione: \(C_{pn}, C_{par} = \SI{5}{\pico\farad}\), \(C_{schottky} = \SI{125}{\pico\farad}\)}\label{graph:sim}
\end{figure}

Come è possibile notare nel secondo caso la tensione della linea \textit{tgt} non è mai inferiore a \SI{700}{\milli\volt} per la giunzione \textit{pn} mentre nel caso della giunzione metallo-semiconduttore del diodo schottky la tensione associata al livello logico 0 è pari a circa \SI{150}{\milli\volt}. Risulta necessario sottolineare come nel secondo caso l'alta capacitanza causa una lentezza di commutazione non indifferente in quanto il segnale simulato non raggiunge mai il valore di \SI{5}{\volt}

Sfruttando la periferica UART risulta quindi banale l'implementazione della comunicazione DebugWire, oltre a rendere possibile un approccio ad interrupt per la scrittura del firmware.

\subsection{Implementazione effettiva}

Data la scelta di utilizzare la scheda \textit{Arduino UNO R3} modificandola, si è reso necessario l'utilizzo del solo pin 13 per la comunicazione con il target, pin non appartenente alla periferica UART dell'ATMega16U2\cite{avr:m16u2}, essendo esso collegato direttamente al pin di reset dell'ATMega328P(si veda il documento~\ref{app:r3-schematic}).

Di conseguenza si è reso necessario scrivere un'implementazione software del protocollo seriale tramite un solo pin.

La prima difficoltà di implementazione riguarda la gestione del pin per l'utilizzo OpenDrain: la piattaforma AVR non supporta nativamente in hardware tale funzione, rendendo necessaria la gestione dello stato del pin a livello software.

Vi sono tre registri di gestione di un pin nell'architettura AVR:\ \texttt{PORTx, DDRx e PINx}. A ogni bit di questi registri è associato un pin fisico e il relativo stato.

Attraverso quanto è rappresentato nella \cref{fig:avr-pin} possiamo valutare le varie condizioni nelle quali il pin fisico può trovarsi in funzione dello stato dei bit relativi ai tre registri elencati in precedenza.

\begin{figure}[t]
    \centering
    \includegraphics[page=85, width=.85\textwidth,trim={40mm 125mm 35mm 45mm},clip]{../biblio/docs/m328.pdf}    \caption[Immagine ottenuta dal documento\cite{avr:m16u2}, fig. 12-2]{Diagramma funzionale dell'hardware relativo a un generico pin della famiglia AVR\cite[fig. 12-2]{avr:m16u2}}\label{fig:avr-pin}
\end{figure}

Alla scrittura del registro \texttt{DDRx} viene asserita la linea WDx, la quale salva lo stato del bit associato al pin nel relativo registro pilotato da essa. Questo registro controlla, tramite la sua uscita \texttt{Q}, un buffer il quale stabilisce la  configurazione del circuito commutando due stati: input e output.

In particolare, se lo stato salvato nel registro \texttt{DDRx} è 1 il pin sarà pilotato con livello logico `forte'' a valore definito dallo stato dell'uscita \texttt{Q} del registro \texttt{PORTx} controllato dalle linee \texttt{WRx}.

Se, invece, lo stato del pin viene posto come input (\texttt{DDRx} posto a 0), è possibile pilotare il FET che controlla il pull-up dell'uscita. Questo accade perché il segnale che rappresenta la direzione del pin è input negato della porta AND che controlla lo stato del pull-up; per questo motivo, il valore 0 del registro \texttt{DDRx}, nel caso il circuito sia configurato come input, permette alla porta di avere risultato 1 se lo stato del registro \texttt{PORTx} è pari a 1.
Tale condizione non ha ripercussioni fisiche in quanto il segnale dell'uscita \texttt{Q} del registro \texttt{PORTx} sarebbe ignorato in quanto il buffer di controllo è disabilitato.

L'ottenimento dello stato del pin può avvenire in qualunque momento tramite la lettura del registro \texttt{PINx}, la quale asserirà la linea \texttt{RPx} e riporterà lo stato salvato nello stadio di sincronizzazione.

La scrittura del registro \texttt{PINx}, illogica dal punto di vista funzionale in quanto esso rappresenta lo stato corrente del pin, viene reindirizzata al controllo del multiplexer posto in ingresso al registro \texttt{PORTx}, in modo da poter invertire lo stato del pin senza averlo precedentemente letto.
Tale funzionalità permette di dimezzare la quantità di operazioni necessarie all'inversione dello stato, rendendo non necessaria la lettura del valore corrente per calcolarne l'inverso.

È possibile osservare la mancanza di uno stato \textit{open drain}.

Risulta quindi necessario stabilire due sequenze di operazioni per portare il pin da livello logico alto ``debole'' a livello logico basso ``forte'' e viceversa. In particolare la transizione da livello logico alto a livello logico basso deve avvenire precedentemente alla configurazione della direzione del pin. Questo garantisce che non vi siano possibilità di conflitti potenzialmente catastrofici, considerando il fatto che il segnale che determina l'attivazione del pull-up è anche responsabile dello stato del pin.

Analogamente per la conversione da livello logico basso a livello logico alto il cambio di stato dovrà avvenire successivamente al cambio di direzione.

Così facendo si riducono le possibilità di guasto e si minimizzano i tempi di incertezza dove il pin è in configurazione di input ma il pull-up è disabilitato, i quali si limitano al tempo intercorso tra i due cambi di configurazione: Al fine di sopprimere tali periodi di incertezza è possibile utilizzare un resistore di pull-up esterno sulla linea.

\subsubsection{Implementazione del protocollo di comunicazione}

L'implementazione della comunicazione seriale emulata a livello software è soggetta a vincoli relativi al tempo di esecuzione.

L'implementazione si basa sull'utilizzo del timer TIMER1, un timer a 16 bit in grado di generare interrupt di comparazione e sul rilevamento della caduta da livello logico alto a basso per identificare un bit di inizio trasmissione.

Il concetto sul quale si basa il funzionamento consiste nel mantenere il timer in esecuzione ed eventualmente resettarne il conteggio nel caso si renda necessario una re-sincronizzazione in ricezione.

Entrambe le azioni di trasmissione e ricezione vengono implementate come una macchina a stati la quale iterazione è controllata dall'interrupt di comparazione di TIMER1 e avvitata da un evento quale una chiamata alla funzione di invio o dalla ricezione di uno \textit{start bit} UART.\@

Entrambe le funzionalità sono divise in due domini di esecuzione: l'esecuzione invocata dall'utente o da un evento esterno (\textit{start bit}) dove avviene la configurazione e la preparazione dei dati e l'esecuzione la macchina a stati ad ogni interrupt di comparazione. 

La funzionalità di invio è implementata tramite un meccanismo di accodamento per due processi produttore-consumatore: alla prima invocazione della funzione di invio il byte viene salvato nella coda e viene abilitata la macchina a stati mostrata in \cref{fig:phy-state-tx} tramite il flag \texttt{\_OD\_UART\_BUSY} la quale consumerà il dato con il successivo interrupt di comparazione del TIMER1.
Nel caso di aggiunta di un secondo byte alla coda durante l'invio di un dato, verrà lasciata alla macchina a stati la gestione dell'avvio di un nuovo ciclo una volta terminato l'invio corrente invece che tornare allo stato \texttt{IDLE}. 

\begin{figure}[t]
    \centering
    \includegraphics[width=.95\textwidth]{phy-tx-state.pdf}
    \caption[]{Macchina a stati per l'implementazione della trasmissione seriale}\label{fig:phy-state-tx}
\end{figure}

Il comportamento sopra descritto viene riassunto dalla \cref{fig:phy-tx-timing}. Si noti come i cambiamenti di stato e il calcolo dei valori avvenga nell'iterazione precedente all'attuazione per permettere il rispetto delle tempistiche.
Inoltre l'immagine mostra come un eventuale aggiunta di un dato alla coda durante l'invio venga indicato dal flag \texttt{OD\_UART\_TX\_FULL}, il quale causa, una volta terminata l'esecuzione del ciclo di invio del byte attuale, la ripresa della procedura senza fare ritorno allo stato \texttt{IDLE}.

\begin{figure}[p]
    %\checkoddpage%
    %\ifoddpage%
        \begin{adjustbox}{addcode={\begin{minipage}{\width}}{\caption[]{%
            Diagramma delle tempistiche di esecuzione dell'invio di dati sulla linea seriale implementata via software.}\label{fig:phy-tx-timing}\end{minipage}},rotate=90,center}
            \includegraphics[width=\textheight]{phy-tx-timing.pdf}%
        \end{adjustbox}
    %\else
    %    \begin{adjustbox}{addcode={\begin{minipage}{\width}}{\caption[]{%
    %        Diagramma delle tempistiche di esecuzione dell'invio di dati sulla linea seriale implementata via software.}\label{fig:phy-tx-timing}\end{minipage}},rotate=-90,center}
    %        \includegraphics[width=\textheight]{phy-tx-timing.pdf}%
    %    \end{adjustbox}
    %\fi
\end{figure}


La parte di ricezione viene implementata con una seconda macchina a stati mostrata in \cref{fig:phy-rx-state} dove il primo passaggio di stato, da Idle a StartBit avviene alla ricezione di un interrupt relativo al cambiamento di livello logico da 1 a 0 del bus seriale.

La ragione per cui questo passaggio debba avere luogo all'avvenimento di un interrupt consiste nel fatto che il \textit{target} può inviare una risposta in qualsiasi istante temporale (in quanto la comunicazione è asincrona).

Risulta necessario l'utilizzo di una struttura FIFO per il salvataggio dei dati ricevuti dalla quale poi l'utente potrà attingere durante l'esecuzione del software. In particolare il flag \texttt{\_OD\_UART\_AVAIL} indicherà la presenza di dati non ancora confermati nel buffer.

Si rende quindi necessario poter ripristinare il conteggio del TIMER1 al fine di re-sincronizzare il clock di campionamento del bus al centro del bit per i motivi descritti nella \cref{ss:uart}, in particolare facendo riferimento all'\cref{eq:uart-period-receive-delay}. Questo comportamento è riassunto dalla \cref{fig:phy-rx-timing}.

Alla ricezione dell'interrupt di cambio di stato la macchina a stati viene inizializzata e il timer resettato in modo che il successivo interrupt di comparazione avvenga a metà del bit successivo. Ad ogni interrupt il valore del bus viene aggiunto secondo l'\cref{eq:rx-push} al valore temporaneo fino al raggiungimento delle otto iterazioni. A questo punto lo stato passa a \texttt{StopBit}, dove il valore temporaneo viene inserito nella coda e viene asserito il flag \texttt{\_OD\_UART\_AVAIL}.

\begin{equation}\label{eq:rx-push}
    tmp_{i+1} = (bus << 7) | (tmp_i >> 1)
\end{equation}

\begin{figure}[p]
    \centering
    \includegraphics[width=.75\textwidth]{phy-rx-state.pdf}
    \caption[]{Macchina a stati relativa alla ricezione della seriale implementata in software.}\label{fig:phy-rx-state}
\end{figure}

\begin{figure}[p]
    \centering
    \includegraphics[width=.99\textwidth]{phy-rx-timing.pdf}
    \caption[]{Macchina a stati relativa alla ricezione della seriale implementata in software.}\label{fig:phy-rx-timing}
\end{figure}

Il \cref{lst:fe-irq-management} mostra il frammento di codice per la gestione dell'inizio ricezione. 

\noindent\begin{minipage}{\textwidth}
    \begin{lstlisting}[style=C, caption={IRQ di gestione inizio trasmissione}, label=lst:fe-irq-management]
__attribute__((optimize("-Ofast"))) ISR(INT7_vect){
    cli();
    FE_IRQ_DISABLE(); //start a new rx. clear irq
    fast_flags = 0;
    uart_flags |= OD_UART_FLAG_BUSY_MASK; //set busy flag, reset flags
    TCNT1 = 0; //set counter to start at next bit. make correction for timer startup and bad things.
    TIMER_IRQ_ENABLE(); //enable timer and clear irq
    TIMER_IRQ_CLEAR();
    sei();
}
    \end{lstlisting}
\end{minipage}

È possibile osservare come nella compilazione dell'handler dell'interrupt venga privilegiata la velocità di esecuzione anziché lo spazio occupato dal compilato (linea 1), e come il TIMER1 venga impostato a 0 permettendo di eseguire il campionamento nel del tempo di bit successivo. 

È inoltre necessario impostare \texttt{TCNT1 = OCR1A >\textcompwordmark> 2} nel caso si voglia utilizzare frequenze vicine a 125000 bit per secondo in quanto vanno considerati i tempi di esecuzione del codice e di reazione del timer. Questo valore è stato trovato sperimentalmente mediante l'uso di un analizzatore logico.

\section{DebugWire}

Grazie alla possibilità di eseguire istruzioni arbitrarie tramite l'interfaccia di debug, è possibile creare delle funzionalità non previste dal protocollo stesso ma di notevole importanza per l'ergonomia dei processi di analisi e \textit{debugging}.

\subsection{Riconoscimento del target}

Durante l'inizializzazione il debugger leggerà il registro SIGNATURE DebugWire per identificare il componente.

Una sezione di memoria flash del firmware presente sull'ATMega16U2 è stata dedicata al salvataggio di una struttura dati contenente le informazioni necessarie al debugging dei dispositivi supportati, per cui è sufficiente cercare sequenzialmente la coincidenza del valore del registro signature rispetto al campo id per ottenere i parametri specifici del microcontrollore \textit{target}.

La struttura salvata contenente gli indirizzi e le dimensioni viene mostrata con il \cref{lst:struct-dw-dev}

\noindent\begin{minipage}{\textwidth}
    \begin{lstlisting}[style=C, caption={Strutture utilizzate nel codice finale per il salvataggio e la ricerca dei parametri associati al target connesso}, label=lst:struct-dw-dev]
    typedef struct dw_device_definition{
        uint16_t signature;
        uint16_t sram_base;         //first sram address after extended io
        uint16_t sram_end;          //first sram address after extended io
        uint8_t flash_page_end;     //words per page
        uint16_t flash_end;         //last flash valid word
        uint16_t eeprom_end;        //first eeporom address after io and extended io
        uint8_t reg_spmcsr;
        uint8_t reg_dwdr;
        uint8_t reg_eearl;
        uint8_t reg_eecr;
        uint8_t reg_eedr;
    } __attribute__((packed)) dw_device_definition_t;

    struct dw_devices{
        uint16_t items;
        dw_device_definition_t devices[];
    } __attribute__((packed));
    \end{lstlisting}
\end{minipage}

\subsection{Programmazione delle memorie non volatili}

Il protocollo DebugWire non permette di accedere in scrittura alle memorie non volatili, impedendone così la programmazione tramite tale interfaccia.

Prendendo spunto da quanto riportato sul datasheet della maggior parte dei dispositivi AVR\cite[34]{avr:m328p}\cite[sec 26.2.5]{avr:m328p}, è possibile ideare una breve routine eseguibile passo-passo dal debugger per la scrittura di tali memorie.

Bisogna però trovare un modo per inviare il dato, o i dati, da scrivere nella memoria.

Una possibile soluzione potrebbe essere quella di scrivere il byte o la pagina in RAM e utilizzare istruzioni \texttt{ld}, ma questo approccio richiederebbe un numero elevato di  istruzioni e causerebbe lunghi tempi di programmazione.

La soluzione adottata è quella di leggere o scrivere il registro \texttt{DWDR}, un registro dedicato alla comunicazione tra target e \textit{debugger} tramite la periferica DebugWire, al quale l'utente non ha alcun tipo di accesso.

Dati i test eseguiti, una scrittura del registro tramite i comandi descritti alla~\cref{sss:dw-mem-io} (il registro si trova ad un indirizzo noto) richiede un ulteriore byte inviato sulla linea seriale che verrà salvato in tale locazione\cite{site:dw-reverse-engeneering}. Analogamente la sua lettura comporta un ulteriore byte inviato dal target rappresentate il valore salvato\cite{site:dw-reverse-engeneering}.

I documenti~\ref{app:dw-flash-prog}~e~\ref{app:dw-eeprom-prog} riportano l'implementazione di codice eseguibile dal debugger per la programmazione delle memorie non volati.

Da tali documenti possiamo osservare come il codice sia fortemente dipendente dal debugger per la preparazione del contesto, ovvero necessita che, prima dell'esecuzione, siano eseguite certe istruzioni di preparazione quali salvataggio dello stato dei registri e preparazione delle costanti e indirizzi nei registri utilizzati.

Inoltre la scrittura dell'algoritmo di programmazione della memoria flash è stata sviluppata evitando la dipendenza da un buffer contenente l'intera pagina da programmare precedentemente alla chiamata, bensì è possibile popolare il buffer temporaneo a blocchi di dimensione variabile prima della programmazione della memoria.

Questo permette di scrivere codice a bassissimo impatto sulla quantità di memoria SRAM utilizzata, condizione necessaria per lo sviluppo su ATMega16U2 in quanto la memoria SRAM totale disponibile non supera i \SI{512}{byte}\cite{avr:m16u2}.

\subsection{Salvataggio stato di esecuzione}

Come anticipato in precedenza, l'esecuzione di azioni tramite debug wire comporta la sovrascrittura di alcuni registri al fine di configurare le azioni prima dell'operando GO, come mostrato dalle \cref{fig:dw-reg-rw-com,fig:dw-mem-rw-com}, comportando così una modifica dello stato dei registri inattesa e imprevedibile dal firmware in esecuzione.

Il solo cambio del valore del Program Counter comporterebbe la ripresa dell'esecuzione da un punto inatteso del codice compilato senza alcun contesto logico.

È quindi necessario creare un sistema di salvataggio temporaneo dello stato in SRAM permettendone così il ripristino al termine delle operazioni.

A tal fine è stata identificata l'interdipendenza delle operazioni DebugWire e il loro utilizzo dei registri come mostrato dalla \cref{fig:dw-wrt-deps}

\begin{figure}[hb]
    \centering

    \resizebox{.95\textwidth}{!}{%
        \begin{tikzpicture}
            \draw (0,0) rectangle (2, 0.5) node[pos=.5] {PC};
            \draw (2,0) rectangle (4, 0.5) node[pos=.5] {HWBP};
            \draw (4,0) rectangle (6, 0.5) node[pos=.5] {r30, r31};
            \draw (6,0) rectangle (8, 0.5) node[pos=.5] {r28, r29};
            \draw (8,0) rectangle (10, 0.5) node[pos=.5] {r0};
            \draw (10,0) rectangle (12, 0.5) node[pos=.5] {IR};
            \draw (12,0) rectangle (14, 0.5) node[pos=.5] {r26, r27};
            \draw (14,0) rectangle (16, 0.5) node[pos=.5] {r1};
            \draw (0, 2) rectangle (4, 3) node[pos=.5] {REG\_RW};
            \draw (0, 4) rectangle (6, 5) node[pos=.5] {FLASH\_R, SRAM\_RW};
            \draw (10, 4) rectangle (12.5, 5) node[pos=.5] {EXE};
            \draw (12, 7) rectangle (2, 6) node[anchor=south west] {EEPROM\_RW};
            \draw (0, 8) rectangle (16, 9) node[pos=.5] {FLASH\_W};

            \draw [-stealth](1, 2) -- (1, 0.5);
            \draw [-stealth](3, 2) -- (3, 0.5);
            \draw [-stealth](4.5, 4) -- (4.5, 0.5);
            \draw [-stealth](7.3, 6) -- (7.3, 0.5);
            \draw [-stealth](9.3, 6) -- (9.3, 0.5);
            \draw [-stealth](11, 4) -- (11, 0.5);
            \draw [-stealth](13, 8) -- (13, 0.5);
            \draw [-stealth](15, 8) -- (15, 0.5);

            \draw [-stealth](2, 4) -- (2, 3);
            \draw [-stealth](11, 6) -- (11, 5);
            \draw [-stealth](12.25, 8) -- (12.25, 5);

            \draw (6.6, 8) -- (6.6, 7);
            \draw [dashed](6.6, 7) -- (6.6, 6);
            \draw [-stealth](6.6, 6) -- (6.6, 0.5);

            \draw (8.6, 8) -- (8.6, 7);
            \draw [dashed](8.6, 7) -- (8.6, 6);
            \draw [-stealth](8.6, 6) -- (8.6, 0.5);

            \draw (1, 8) -- (1, 5);
            \draw [dashed](1, 5) -- (1, 4);
            \draw [-stealth](1, 4) -- (1, 3);

            \draw (5, 6) -- (5, 5);
            \draw [dashed](5, 5) -- (5, 4);
            \draw [-stealth](5, 4) -- (5, 0.5);

            \draw (5.5, 8) -- (5.5, 7);
            \draw [dashed](5.5, 7) -- (5.5, 6);
            \draw (5.5, 6) -- (5.5, 5);
            \draw [dashed](5.5, 5) -- (5.5, 4);
            \draw [-stealth](5.5, 4) -- (5.5, 0.5);
        \end{tikzpicture}
    }

    \caption[]{Diagramma delle dipendenze di utilizzo dei registri target per le azioni DebugWire}\label{fig:dw-wrt-deps}
\end{figure}

È possibile individuare un cammino comune di salvataggio e ripristino dei registri per tutte le operazioni. In particolare è evidente come tutte le operazioni, ad eccezione di \texttt{EXE}, dipendano da \texttt{REG\_RW}, e come le operazioni di scrittura sulle memorie non volatili dipendano da scritture sugli stessi registri di \texttt{SRAM\_RW}.

La sequenza di salvataggio e ripristino viene mostrata nella la \cref{fig:dw-wrt-seq}. L'immagine mostra una pila di registri per la quale, dato un punto di ingresso comune in funzione dell'azione da eseguire, sarà necessario salvare tutti i registri visitati nella discesa della pila fino al punto di uscita definito da tale operazione. Per esempio, l'azione \texttt{EEPROM\_RW} dovrà salvare i registri \texttt{PC}, \texttt{HWBP}, \texttt{Z (r30, r31)}, \texttt{IR}, \texttt{Y(r26, r27)} e \texttt{r0}. È possibile notare come i registri elencati siano anche quelli utilizzati dal codice presente al documento in appendice~\ref{app:dw-eeprom-prog}

\begin{figure}[ht]
    \centering
    %\resizebox{.95\textwidth}{!}{%
        \begin{tikzpicture}
            
            \draw [fill=yellow!50] (0,0) rectangle (3, 1) node[pos=.5] {r1};
            \draw [fill=orange!50] (0,1) rectangle (3, 2) node[pos=.5] {X};
            \draw [fill=green!50] (0,2) rectangle (3, 3) node[pos=.5] {Y, r0};
            \draw [fill=blue!50] (0,3) rectangle (3, 4) node[pos=.5] {IR};
            \draw [fill=brown!50] (0,4) rectangle (3, 5) node[pos=.5] {Z};
            \draw [fill=gray!50] (0,5) rectangle (3, 6) node[pos=.5] {PC, HWBP};

            \draw (-0.3, 0) rectangle (0, 6);
            \draw [-stealth] (-0.15, 5.5) -- (-0.15, 0.5);

            \draw [stealth-] (-0.3, 5.5) -- (-1.5, 5.5) node[left] {All actions};
            \draw [stealth-] (-0.3, 3.5) -- (-1.5, 3.5) node[left] {EXE};

            \draw [-stealth] (3, 5.5) -- (4.5, 5.5) node[right] {REG\_RW};
            \draw [-stealth] (3, 4.5) -- (4.5, 4.5) node[right] {FLASH\_R, SRAM\_RW};
            \draw [-stealth] (3, 2.5) -- (4.5, 2.5) node[right] {EEPROM\_RW};
            \draw [-stealth] (3, 1.5) -- (4.5, 1.5) node[right] {FLASH\_CLEAR\_PAGE};
            \draw [-stealth] (3, 0.5) -- (4.5, 0.5) node[right] {FLASH\_W};
            \draw [-stealth] (3, 3.5) -- (4.5, 3.5) node[right] {EXE};
        \end{tikzpicture}
    %}

    \caption[]{Diagramma dei salvataggi e ripristini dei registri in funzione dell'operazione da eseguire}\label{fig:dw-wrt-seq}
\end{figure}

\subsection{Software Breakpoints}

L'aggiunta della possibilità di scrivere la memoria flash consente l'implementazione dei software breakpoints.

Un breakpoint è un indicatore associato a un indirizzo di memoria dove il codice è in esecuzione con il fine di interrompere l'esecuzione dell'algoritmo e passare il controllo al debugger per effettuare le operazioni di analisi e ispezione.

Questi consistono nella sovrascrittura di un'istruzione con l'opcode corrispondente all'istruzione \texttt{break} causando così l'\textit{halt} della CPU e l'intervento del debugger prima dell'esecuzione della stessa.
Alla ripresa dell'esecuzione il debugger caricherà in memoria l'istruzione originale e riprenderà il flusso del codice.

Un primo approccio per la scrittura del codice relativo a questa feature consiste nell'aggiornare la memoria flash scrivendo un'istruzione BREAK\footnote{0x0000} non appena possibile e salvare in una struttura dati la coppia \[<indirizzo>:<opcode>\]

Un possibile algoritmo viene esibito di seguito. Questo algoritmo, eseguito dal server GDB presente sull'ATMega16U2, ha un impatto sull'utilizzo della memoria SRAM del controllore di 18 byte, grazie al fatto che è possibile riempire il buffer di scrittura del \textit{target} prima della cancellazione della pagina in programmazione\cite{avr:m328p}.

Sia \(address\) l'indirizzo dell'istruzione da sostituire (word address), \(pagelen\) il numero di word in una pagina.

L'algoritmo di aggiornamento è definito secondo i passi a seguire:

\begin{enumerate}
    \item Salvataggio dei registri come definito in \cref{fig:dw-wrt-seq} per l'azione \texttt{FLASH\_W} (14 byte)
    \item Si ponga l'indirizzo di pagina, utilizzando 2 byte, come definito dall'~\cref{eqn:page-address}.
    
    \begin{equation}\label{eqn:page-address}
    pageaddr = \left\lfloor\frac{address}{pagelen}\right\rfloor pagelen
    \end{equation}

    \item Si inizi la scrittura di una pagina e, per ogni indirizzo da \(pageaddr\) a \(address\) (escluso), si legga in una variabile temporanea (2 byte) il valore della memoria flash a quell'indirizzo e si aggiunga al buffer di scrittura presente nell'integrato (si veda il documento~\ref{app:dw-flash-prog}).
    \item Si scriva nel buffer l'opcode corrispondente all'istruzione BREAK.\@ 
    \item Per ogni indirizzo da \(address + 1\) a \(pageaddr + pagelen - 1\) si popoli il buffer con quanto letto. 
    \item Si esegua l'azione Page Clear all'indirizzo \(pageaddr\)
    \item Si esegua l'azione di programmazione della pagina.
    \item Si ripristini lo stato dei registri invertendo quanto eseguito al punto 1.
\end{enumerate}

Quanto riportato, seppur una soluzione valida, causa un deterioramento della memoria flash e innalza notevolmente i tempi di debug, inserendo attese notevoli tra il posizionamento di un breakpoint e un altro in quanto per ogni breakpoint avviene la riprogrammazione dell'intera pagina dove esso è collocato.

L'algoritmo finale risolve queste problematiche adottando una gestione ``\textit{lazy}'' dei breakpoint e accorpando modifiche alle pagine di memoria flash solo al momento precedente all'esecuzione.
Questo permette di evitare tutte le riscritture date dall'eventuale indecisione del programmatore o errori di inserimento.

Un breakpoint software viene definito con la struttura presentata nel \cref{lst:dw-swbp-struct}. I flag \texttt{active} e \texttt{stored} permettono di identificare le azioni da intraprendere al momento dell'applicazione delle modifiche in memoria.

\noindent\begin{minipage}{\textwidth}
    \begin{lstlisting}[style=C, caption={Struttura utilizzata per il salvataggio dei riferimenti ai breakpoint software}, label=lst:dw-swbp-struct]
    typedef struct dw_sw_brkpt{
        uint16_t address;
        uint16_t opcode;
        uint8_t active : 1;
        uint8_t stored : 1;
    } dw_sw_brkpt_t;
    \end{lstlisting}
\end{minipage}

In particolare si ha che è necessario eseguire un'azione in memoria se i due flag sono discordanti: se un breakpoint è stato abilitato ma non è stato scritto in memoria sarà necessario sostituire l'istruzione presente all'indirizzo \(address\), mentre se un breakpoint è salvato (\texttt{stored} = 1) ma disabilitato sarà necessario ripristinare \texttt{opcode} all'indirizzo specificato.

Nel caso di aggiunta o rimozione di un breakpoint l'indirizzo viene ricercato all'interno della lista di breakpoint precedentemente definiti comparando l'indirizzo. Se il breakpoint era stato precedentemente definito allora il riferimento viene modificato impostando la variabile \texttt{active} al valore consono mentre in caso contrario viene creato un nuovo riferimento in coda.

Prima della ripresa dell'esecuzione la lista di breakpoint viene ordinata mediante insertion sort secondo i criteri elencati a seguire e vengono rimossi i riferimenti con indicatori \textit{stored} e \textit{active} disabilitati.

I criteri di ordinamento sono i seguenti:
\begin{itemize}
    \item se due riferimenti sono entrambi non salvati e inattivi non viene effettuata l'inversione e sono considerati uguali ignorando l'indirizzo.
    \item se il primo riferimento è inattivo e non salvato mentre il secondo è o salvato o attivato, allora viene eseguita l'inversione
    \item se sono tutti e due attivi o salvati, vengono comparati gli indirizzi e avviene l'inversione se il primo indirizzo è maggiore del secondo.
\end{itemize}

Così facendo si ottiene una lista di riferimenti ordinati per indirizzo crescente con i riferimenti da eliminare posti in coda a scapito di quest'ultimo, permettendo quindi la rimozione dei riferimenti inattivi e non salvati perché non più esistenti partendo dal fondo e eliminando fino a trovare un riferimento attivo o salvato.

Ora risulta possibile accorpare le scritture in memoria con un algoritmo simile a quanto riportato in precedenza considerando però la presenza di più breakpoint per pagina.

Sarebbe possibile rendere la ricerca e l'ordinamento più efficiente utilizzando algoritmi quali ricerca binaria e qsort ma non è stati ritenuto necessario essendo il numero massimo di riferimenti limitato a venti.

\section{Server GDB}

L'implementazione del server GDB è la seconda parte fondamentale del progetto proposto.

Come descritto in precedenza nella \cref{fig:gdb-server-tunnels} la comunicazione con l'\textit{host} avviene tramite USB.\@ Tale comunicazione viene implementata dalla libreria LUFA\cite{git:lufa} per semplificare lo sviluppo.

La gestione della comunicazione avviene mediante un'implementazione a flussi, limitando la quantità di dati salvata in SRAM a \SI{64}{Byte} prima di eseguire le operazioni. Questo perché, come mostrato nell'\cref{eq:gdb-checksum} il checksum può essere calcolato durante la lettura senza la necessità di fare riferimento ad altri dati se non al'ultimo byte letto.

Una volta ottenuto il comando, sarà compito della funzione implementante di leggere eventuali dati aggiuntivi necessari quando richiesto.

Un esempio di questa architettura lo si ha nell'implementazione della scrittura dei registri. Tale comando, definito dalla \cref{fig:Gcmd}, ha lunghezza e ordine dei campi noti consentendo di implementare un'algoritmo con lettura parziale delle informazioni prima della scrittura affidandosi al buffering degli endpoint USB di \textit{host} e \textit{device}\cite[ch. 20]{avr:m16u2}.

\begin{figure}
    \centering
    \begin{bytefield}{32}
        \bitbox{2}{\texttt{\$}}
        \bitbox{2}{\texttt{G}}
        \bitbox{8}{\texttt{r0-r31}}
        \bitbox{4}{\texttt{SREG}}
        \bitbox{8}{\texttt{SP}}
        \bitbox{8}{\texttt{PC}}
    \end{bytefield}
    \caption[]{Comando GDB di scrittura registri\cite{site:gdbproto}}\label{fig:Gcmd}
\end{figure}

Sorge quindi il problema di comandi pacchettizzati: La scrittura della memoria flash avviene inviando pacchetti multipli di dimensione limitata contenenti i dati da scrivere ad un dato indirizzo senza tenere conto della divisione in pagine\footnote{Il protocollo permette di definire un limite massimo ai pacchetti, per cui scritture di dati di lunghezza maggiore di quanto impostato vengono divise in più comandi. La lunghezza dei pacchetti può non essere multipla della lunghezza delle pagine.}. È dunque necessario mantenere una ``sessione'' di scrittura tenendo traccia dell'ultimo indirizzo scritto e della pagina corrente per riprendere il riempimento del buffer temporaneo sul dispositivo \textit{target} con dati validi.

Il generico pacchetto di scrittura della memoria è definito dalla \cref{fig:Mcmd}.

Per permettere la scrittura delle diverse memorie, esse sono identificate dell'offset dell'indirizzo del quale viene effettuato come descritto dalla \cref{tab:gdb-mem-addr}. L'indirizzo reale dell'operazione è definito come l'indirizzo inviato sottratto del valore dell'inizio dell'intervallo.

\begin{figure}
    \centering
    \begin{bytefield}{32}
        \bitbox{2}{\texttt{\$}}
        \bitbox{2}{\texttt{M}}
        \bitbox{4}{\texttt{addr}}
        \bitbox{1}{\texttt{:}}
        \bitbox{4}{\texttt{len}}
        \bitbox{1}{\texttt{:}}
        \bitbox{18}{\texttt{data}}
    \end{bytefield}
    \caption[]{Comando GDB di scrittura della memoria\cite{site:gdbproto}}\label{fig:Mcmd}
\end{figure}

\begin{table}[h]
    \centering
    \begin{tabular}{ c l }
        \textbf{Intervallo di indirizzi} & \textbf{Memoria} \\
        \hline%
        \texttt{0x000000 - 0x7FFFFF} & FLASH \\
        \texttt{0x800000 - 0x80FFFF} & SRAM\\
        \texttt{0x810000 - 0xFFFFFF} & EEPROM\\
        \hline%
    \end{tabular}
    \caption[]{Tabella riassuntiva della mappatura delle memorie ad indirizzi\cite{site:gdb}}\label{tab:gdb-mem-addr}
\end{table}

La scrittura della memoria flash avviene secondo il seguente algoritmo:
Sia \(last\_addr\) l'ultimo indirizzo scritto dalla precedente esecuzione di scrittura e \(is\_mem\_wrt\) la variabile di stato per la procedura.
Sia l'operazione di scrittura richiesta definita dalle variabili \(addr\) e \(len\). Sia \(PAGEEND\) la quantità di byte in una pagina per il dispositivo ed infine \(page\_address\) la quantità definita dall'~\cref{eqn:page-address}.

\begin{enumerate}
    \item Se \(is\_mem\_wrt\) è attiva, ovvero se è già in corso un'operazione di scrittura, si vada al passo~\ref{step:wrt_bytes}
    \item Si ponga \(last\_addr = addr\)
    \item\label{step:wrt_bytes} Se \(addr > last\_address\), leggere e ripopolare la stessa pagina di memoria per l'intervallo \(\left[last\_address + 1, addr\right[\)
    \item\label{step:populate} Popolare la pagina per l'intervallo \[\left[addr, addr + \min\left\{PAGEEND - address + page\_address, len\right\}\right[ \]
    \item Se \(page\_address < len\) si ponga \(len = len - PAGEEND + addr - page\_address\), si ponga \(addr = addr + PAGEEND\) e si ritorni al punto~\ref{step:populate}
    \item Se si è giunti a fine della pagina da programmare eseguire la procedura di cancellazione e programmazione~\ref{chap:dw}
    \item Se il comando successivo non è un comando di memoria e la pagina corrente non è ancora stata scritta, eseguire la procedura di cancellazione e programmazione per poi terminare la sessione disattivando \(is\_mem\_wrt\). In caso contrario si ritorni al punto 1.
\end{enumerate}

Vi è un effetto collaterale: affinché tutti i dati siano programmati è necessario terminare la scrittura al limite di una pagina oppure è possibile inviare un comando non correlato (e.g.\ lettura di un byte dalla memoria) per forzare la programmazione.

\section{Real Time Terminal}\label{s:rtt}

Come precedentemente anticipato, questo progetto mira a costituire un insieme di strumenti e funzionalità per il supporto alla programmazione nel mondo embedded AVR.\@

Nei capitoli precedenti è stata discussa l'implementazione di un server GDB per effettuare il debugging sul controllore e permettere l'ispezione \textit{in loco} degli effetti dei programmi e l'alterazione delle risorse durante l'esecuzione a fini diagnostici. 

Affiancata alla pratica del debugging possiamo classificare un altro metodo diagnostico: il \textit{logging}.

Questa seconda pratica --- spesso usata in modo scorretto per analizzare un problema algoritmico in una porzione di codice limitata--- consente di generare messaggi analizzabili successivamente a fine di \textit{auditing}; con ciò si intende l'analisi di messaggi di log raccolti nel periodo precedente passati per individuare malfunzionamenti o vulnerabilità inattesi e imprevisti occorsi durante la normale esecuzione del codice.

I messaggi di log sono anche utili per individuare in quale macro area del codice si trova un possibile baco per poi indagare l'effettivo comportamento inatteso tramite debugger una volta identificata la causa scatenante.

L'attenzione si sposta dunque su come implementare tale funzionalità sulla piattaforma AVR.\@ La maggior parte dei progetti e delle piattaforme utilizza la periferica UART del target al fine di interagire con l'host, impedendone così l'utilizzo da parte del programmatore per comunicare con altre periferiche. Alcune piattaforme hne anno ottimizzato l'utilizzo dedicando la linea seriale anche alla programmazione, riducendo però lo spazio disponibile nella memoria flash in quanto tale operazione deve essere svolta da un bootloader dedicato e collocato nella memoria flash del \textit{target}. 

In questo progetto tale funzionalità viene implementata %da tetino
mediante la collaborazione del server GDB il quale maschererà tali eventi alle procedure di debug.

Così facendo è possibile identificare due tipologie di interruzioni da parte del \textit{target}: Interruzioni causate al raggiungimento di un breakpoint oppure interruzioni relative all'invio di un messaggio. Tale distinzione avviene leggendo lo stato di una struttura, definita dal~\cref{lst:rtt-struct} posta in principio alla memoria SRAM del \textit{target}.

\noindent\begin{minipage}{\textwidth}
    \begin{lstlisting}[style=C, caption={Struttura utilizzata per il salvataggio dei riferimenti ai breakpoint software}, label=lst:rtt-struct]
    typedef struct{
        uint8_t available : 1;
        uint8_t enabled : 1;
        uint8_t size : 6;
        uint8_t data[64];
    } __attribute__((packed)) rtt_data;
    \end{lstlisting}
\end{minipage}

Si noti che la variabile \texttt{rtt\_data.enabled} non viene mai scritta dal \textit{target}. La variabile all'avvio è in stato non inizializzato ma viene immediatamente posta a valore nullo grazie all'intervento del firmware sviluppato per l'ATMega16U2. Così facendo si ha la certezza di avere il controllo assoluto di tale variabile impedendo il disallineamento sull'abilitazione della funzionalità RTT tra target e server GDB.\@

A livello di libreria, come mostrato dall'allegato~\ref{app:rtt-lib} alle righe 9 e 10, l'esecuzione dell'istruzione \texttt{break} avviene solo se la variabile \texttt{rtt.enable} è posta a 1, ovvero se il server GDB ha precedentemente abilitato la funzionalità in questione. In tal caso vengono impostate le variabili \texttt{rtt.available} e \texttt{rtt.size} prima di asserire la linea di debug per segnalare l'interruzione.

Si noti inoltre che la libreria viene completamente eliminata in caso di compilazione di una versione di rilascio (righe 3 e 4).

La \cref{fig:rtt-gdbsrv} mostra la procedura di gestione di un'interruzione da parte del server GDB.\@ Si può notare come, nel caso la funzionalità RTT sia abilitata, vengano eseguite più operazioni per la gestione dell'interruzione.

Nel caso RTT sia abilitato il server GDB, prima di comunicare l'interruzione all'\textit{host}, leggerà dalla memoria del target la variabile \texttt{rtt.available}. Se tale variabile risultasse vera, verrebbe effettuata la lettura di \texttt{rtt.size} byte dal buffer e comunicata tale stringa correttamente formattata al client tramite il comando GDB `\texttt{O}'\cite{site:gdbproto} per poi riprendere l'esecuzione. Nel caso contrario si deduce che l'interruzione è avvenuta per il raggiungimento di un breakpoint e di conseguenza di comunicata l'interruzione.

Tale funzionalità è detta \textit{Proxy}, ovvero le comunicazioni tra \textit{target} e server vengono intercettate ed eventualmente modificate o scartate.

\begin{figure}[b]
    \centering
    \includegraphics[width=0.8\textwidth]{rtt-handling.pdf}
    \caption[]{Diagramma di attività descrivente il procedimento di gestione di un'interruzione da parte del target}\label{fig:rtt-gdbsrv}
\end{figure}

Successivamente è necessario configurare il compilatore per posizionare la struttura di controllo \texttt{rtt\_data}. A tale scopo è stato modificato lo script di linking originale di \textit{avr-gcc}, del quale un dettaglio è mostrato nel \cref{lst:link-rtt}, apportando una modifica alla sezione \texttt{.data} includendo in principio ad essa una sezione logica \texttt{.dbgdata} nella quale viene posta la struttura di controllo, come evidente dalla dichiarazione della riga 6 dell'allegato~\ref{app:rtt-lib}.

\noindent\begin{minipage}{\textwidth}
    \begin{lstlisting}[label=lst:link-rtt, caption={Sezione del linker script modificato per la compilazione della libraria rtt.}]
    .data : 
    {
        PROVIDE(__dbg_data_start = .);
        KEEP(*(.dbgdata))
        PROVIDE(__dbg_data_end = .);
        PROVIDE (__data_start = .);
        *(.data)
        *(.data*)
[...]
        . = ALIGN(2);
         _edata = . ;
         PROVIDE (__data_end = .) ;
      }  > data AT> text
    \end{lstlisting}
\end{minipage}

È necessario osservare che la sezione \texttt{.data} viene inizializzata grazie all codice standard di \textit{avr-libc}. Tale operazione viene impedita impostando l'indirizzo di inizio della seziona a seguire della sezione logica \texttt{.dbgdata} (linea 6). 

Affinché il server GDB abiliti il terminale rtt è necessario inviare il comando \texttt{monitor rtt enable}.
I comandi \texttt{monitor} costituiscono il metodo di gestione di comandi personalizzati all'interno del protocollo GDB.\@