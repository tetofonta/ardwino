\chapter{Introduzione}

Possiamo vedere la programmazione di micro-controllori come una specialità posta a cavallo tra due scienze ingegneristiche, l'elettronica e l'informatica.
Capacità del programmatore nel creare firmware in grado di \textit{toccare} il mondo reale comporta una connessione dei due mondi molto diversi tra loro ma da sempre in armonia, rendendo fisica la presenza di un software e virtuale la realtà circostante, in modo di permettere un incontro di due concezioni apparentemente sconnesse.

Ad oggi, essendo in un periodo storico dove la digitalizzazione è ormai esplosa, la quasi totalità di prodotti di consumo contiene uno o, più spesso, più controllori digitali.
Complice lo sviluppo tecnologico della produzione di dispositivi integrati e la pubblicazione di standard aperti riguardanti l'architettura di processori --- quali RISC-V e ARM\cite{site:arm-licensing} ---, i quali, grazie alla produzione di prodotti appartenenti a queste architetture da parte di più aziende del settore, hanno ormai mutato radicalmente il panorama dello sviluppo elettronico digitale.\cite{arm-intel-phone-market}\cite{site:arm-press-200b-chips}

Tra le tecnologie non ``open source'' a bassissimo costo presenti attualmente sul mercato, invece, possiamo trovare la famiglia \textit{Atmel AVR}: Una semplice architettura RISC a 8 bit dalle periferiche limitate e prestazioni massime di 20MIPS\footnote{Million instructions per second} venduta a costi molto ridotti.
Questa famiglia è la più utilizzata per applicazioni a dove è essenziale avere un basso consumo di corrente: per esempio alcuni controllori della famiglia presentano correnti massime di 4mA (80\mu{W} a 5V) e possono raggiungere consumi di 12pW (2\mu{A} a 3V)\cite{avr:tiny4}.

L'architettura AVR è inoltre stata scelta per lo sviluppo della piattaforma open source \textit{Arduino} dall'omonima azienda per favorire la prototipazione rapida e renderla accessibile ad un pubblico ampio, composto da studenti, hobbisti, artigiani e professionisti\cite{site:arduino-about}, dando così alla famiglia AVR maggiore visibilità sulla gamma a basso costo.

Bisogna però sottolineare come il fatto che l'architettura AVR sia proprietaria comporti difficoltà di utilizzo e sviluppo da parte dei programmatori.

Sebbene sia stato distribuito del software open source in grado di compilare (avr-libc\cite{site:avr-libc}, avr-gcc\cite{site:avr-gcc}) per la piattaforma, e siano state rilasciate le specifiche dei vari protocolli di programmazione disponibili\cite{avr:appnote:isp}\cite{avr:appnote:tpi}\cite{avr:appnote:pdi}, non sono state pubblicate informazioni relative alle procedure e protocolli di debug dei micro-controllori, le quali sono implementati negli strumenti di sviluppo proprietari dove non è possibile analizzare il firmware perché protetto (sia dalla lettura fisica che da diritti d'autore in capo alla società).

La pratica di \textit{debugging} consiste nell'interrompere il flusso del codice in esecuzione sul micro-controllore in esame (\textit{target}) tramite un'operazione di \textit{halt} e di analizzare il contenuto di memorie e registri. Il \textit{debugging} consente anche di eseguire le istruzioni ``passo-passo'', al fine di analizzare e trovare errori logici o implementativi nel firmware in sviluppo.

La famiglia AVR implementa due diversi protocolli di debug: JTAG e DebugWire; il primo per componenti ``ad alte prestazioni'' mentre il secondo per i controllori ``\textit{low cost}''.

Obiettivo di questa relazione sarà lo sviluppo di un sistema di aiuto alla programmazione in grado di fornire, attraverso il reverse engineering del protocollo DebugWire\cite{site:dw-reverse-engeneering}, supporto alle operazioni di debug rispettando i principi \textit{open source} e senza utilizzare alcun tipo di materiale proprietario su tutti i fronti delle attività quali 
\begin{itemize}
    \item Sistemi di sviluppo: Verranno mostrate configurazioni per ambienti di programmazione distribuiti con licenze aperte. 
    \item Software di supporto: Si prevede l'utilizzo del software avr-gdb\cite{site:gdb} tramite la creazione di un ``server remoto'' collegato al controllore target. L'utilizzo di software preesistente garantisce un continuo aggiornamento e mantenimento, oltre che permettere alta interoperabilità tra software che lo supportano. Il suo utilizzo sarà essenziale alla configurazione dell'ambiente di sviluppo.
    \item Software: Il software creato sarà reso disponibile con licenza open source.
    \item Hardware: Il processo di sviluppo del sistema sarà basato su una piattaforma hardware open source e già esistente. La piattaforma scelta è \textit{Arduino Uno R3} in quanto essa è la scheda di prototipazione più diffusa.
\end{itemize}

Inoltre verrà sviluppato un sistema di comunicazione interno tra target e debugger sulla sola connessione DebugWire al fine di permettere l'invio di informazioni all'ambiente di sviluppo e visualizzabili nella console di sistema senza impiegare periferiche di comunicazione dedicate a questo compito. Questo permetterà di poter allocare tali periferiche per lo sviluppo effettivo.

È dunque possibile valutare due importanti aspetti migliorativi che conseguono dal completamento di questa relazione: rispetto all'attuale situazione dell'ecosistema di sviluppo della piattaforma \textit{Arduino}, sebbene sia in continuo miglioramento, essa manca di supporto al debugging per le piattaforme \textit{low cost} e di un valido sistema di aiuto alla programmazione composto da strumenti quali autocompletamento del codice, assistenza alla codifica e ``code hinting''.

L'utilizzo di un ambiente di sviluppo completo permette di garantire la familiarità di utilizzo all'utente finale --- essendo pratica comune sviluppare con diverse tecnologie utilizzando lo stesso programma --- e l'integrazione con i suddetti strumenti di assistenza alla programmazione e debug.

La scelta della piattaforma \textit{Arduino Uno R3}, oltre a rispecchiare la filosofia open source, permette di velocizzare le tempistiche di sviluppo avendo fin da subito a disposizione un hardware ben testato.\cite{site:arduino-mini-le}

Il sistema ultimato sarà dunque un set di strumenti complementari e modifiche da apportare alla scheda sopra descritta in modo che chiunque sia in grado di effettuare i cambiamenti per utilizzarlo

La motivazione principale che ha portato alla scelta di realizzare questo progetto è stata la volontà di contribuire allo sviluppo della realtà open source nata intorno a questa disciplina andando a sviluppare un ramo non ancora approfondito. 
Le contribuzioni alle risorse pubbliche, inoltre, consentiranno a coloro che si approcciano allo sviluppo embedded --- in qualità di hobbisti o novizi --- di avere accesso a un sistema più avanzato in grado di offrire supporto alla programmazione, sopperendo dunque alla mancanza di esperienza in alcuni casi e consentendo di velocizzare il processo di identificazione degli errori in altri; rendendo così più efficiente il processo di apprendimento della materia.

Si noti che il lavoro è stato interamente svolto in completa assenza di supporto da parte di programmatori e di software proprietari: Sono state utilizzate solamente risorse disponibili online. 
