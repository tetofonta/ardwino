\chapter{Appendice}
\addtocontents{toc}{\protect\setcounter{tocdepth}{0}}

Di seguito è riportata la lista dei documenti allegati, i quali
sono poi inseriti a seguire.
\vspace*{-25mm}
\listofappendices

\newappendix{Arduino R3 Schematic}\label{app:r3-schematic}
Sorgente: \url{https://www.arduino.cc/en/uploads/Main/Arduino_Uno_Rev3-schematic.pdf}\\
visitato il 07-09-2022

\begin{center}
    \includegraphics%
        [height=.89\textwidth, angle=90]%
        {attachments/Arduino_Uno_Rev3-schematic.pdf}
\end{center}

\newappendix{File di simulazione ngspice per la simulazione adattamento open drain}\label{app:ngspice-bjt}

\begin{lstlisting}[language=txt]
.TEMP=25.0
.OPTIONS ABSTOL=1e-12 GMIN=1e-12 PIVREL=1e-3 ITL1=100 ITL2=50 PIVTOL=1e-13 RELTOL=1e-3 VNTOL=1e-6 CHGTOL=1e-15 ITL4=10 METHOD=TRAP SRCSTEPS=0 TRTOL=7 NODE

R_R1 TGT N_3 10k 
V_V1 TXD 0 DC 0V AC 0 PULSE(0 5V 4u 1n 1n 8u 16u) 
R_R2 N_3 N_1 1k 
Q_Q1 TGT N_1 TXD QNPN 
V_V2 N_3 0 DC 5V AC 0 
C_C1 TGT 0 5p 
.MODEL QNPN NPN

.control
set filetype=ascii
TRAN 4.8e-8 2.4e-5 0 4.8e-8 
write untitled.sch.sim V(TXD) V(TGT)
.endc
.END
\end{lstlisting}

\begin{lstlisting}[language=txt]
.TEMP=25.0

.OPTIONS ABSTOL=1e-12 GMIN=1e-12 PIVREL=1e-3 ITL1=100 ITL2=50 PIVTOL=1e-13 RELTOL=1e-3 VNTOL=1e-6 CHGTOL=1e-15 ITL4=10 METHOD=TRAP SRCSTEPS=0 TRTOL=7 NODE

R_R1 TGT N_3 10k 
V_V1 TXD 0 DC 0V AC 0 PULSE(0 5V 4u 1n 1n 8u 16u) 
V_V2 N_3 0 DC 5V AC 0 
D_D1 TGT TXD DMOD 
C_C1 TGT 0 5p 
.MODEL DMOD D

.control
set filetype=ascii
TRAN 4.8e-8 2.4e-5 0 4.8e-8 
write untitled.sch.sim V(TXD) V(TGT) I(V_V1) I(V_V2)
.endc
.END
\end{lstlisting}


\newappendix{Algoritmo di programmazione memoria Flash tramite DebugWire}\label{app:dw-flash-prog}

\begin{lstlisting}[language=AVR]
    ;L'algoritmo si aspetta i seguenti registri impostati dal debugger:
    ; r26 = const(3)
    ; r27 = const(1)
    ; r28 = const(5)
    ; r29 = const(0x40)
    ; r30 = const(page_address_l)
    ; r31 = const(page_address_h)


    ;clear page
    out SPMCSR, r26 ; PGERS | SPMEN
    spm

    ;write tmp buffer
    ldi r28, 0x11 ; RWWSRE | SPMEN => read while write read enable if bootloader support, else clear tmp buffer
    out SPMCSR, r28
    spm

wrt_buf:
    in r0, DWDR; read data from dw, sent by debugger
    in r1, DWDR; r0:r1 contains the word to be written
    out SPMCSR, r27 ; SPMEN
    spm
    adiw Z, 2
    ;debugger loops to wrt_buf until the full page is written.

    ;issue write
    out SPMCSR, r28 ; PGWRT | SPMEN
    spm
\end{lstlisting}

\newappendix{Algoritmo di programmazione memoria\\EEPROM tramite DebugWire}\label{app:dw-eeprom-prog}

\begin{lstlisting}[language=AVR]
    ;L'algoritmo si aspetta i seguenti registri impostati dal debugger:
    ; r28 = const(4)
    ; r29 = const(2)
    ; r30 = const(address_l)
    ; r31 = const(address_h)

    out EEARH, r31
    out EEARL, r30 ; set write address
    in r0, DWDR ; sent by debugger by dw

    out EEDR, r0 ; set data to be written
    out EECR, r28 ; EEMPE
    out EECR, r29 ; EEPE
\end{lstlisting}

\newappendix{Libreria implementante la funzionalità di terminale in tempo reale (RTT)}\label{app:rtt-lib}

\begin{lstlisting}[style=C]
    #include <string.h>

    #ifdef BUILD_TYPE
    #if BUILD_TYPE == Debug

    volatile rtt_data rtt __attribute__((section(".dbgdata")));

    void rtt_log(const char *buffer, uint8_t size){
        if (!rtt.enabled)
            return;
            
        size &= 0x3F;
        rtt.size = size;

        while(size--)
            *(rtt.data + size) = *(buffer + size);
            
        rtt.available = 1;
        asm volatile("break");
    }

    void rtt_init(void){
        rtt.available = 0;
        rtt.size = 0;
    }

    #endif
    #endif
\end{lstlisting}

\addtocontents{toc}{\protect\setcounter{tocdepth}{3}}